class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """ 
#         Time Complexity: O(N^2) where N is the length of graph, as the graph is given in adjacent matrix form.

# Space Complexity: O(N)

        def bfs(i):
            queue, visited = [i], [i]
            path_node = 0
            while(queue):
                cur = queue.pop(0)
                for idx, value in enumerate(graph[cur]):
                    if value ==1 and idx not in visited:
                        queue.append(idx)
                        path_node += 1
                        if idx in initial: #if the child node is also infected return -1 then we cannot use this node
                            return -1
                        visited.append(idx)
            return path_node
        
        record = dict()

        for node in initial:
            record[node] = bfs(node)

        candidate = record[max(record, key=record.get)] #select graph with maximum connected components to minimize malware spread
        #print(candidate)
        res = []
        print(record)
        for k, v in record.items():
            if v==candidate:
                res.append(k)
        return min(res) #if all are infected return min index
    
    
     #if the subgraph has two infected nodes then we cannot remove infection. So we find subgraph with just one infected node
# Algorithm:  1.  go through every infected node
# 2.if this subgraph have > 2 infected nodes go to step 1, else go step3
# 3.compute graph size
